package ru.spbu.arts.multithreading;

public class Monkeys {

    //принцип: стараться обходиться без статических методов.
    public static void main(String[] args) {
        new Monkeys(); //создаем одну программу про обезьянок
    }

    private int bananas = 1_000_000;

    private Monkeys() {
        //здесь основная логика программы

        /*
        //одна обезьянка ест бананы
        int eaten = 0;
        while (bananas > 0) {
            bananas--; // bananas = bananas - 1
            eaten++; // eaten = eaten + 1
        }

        //%d - подставить число в десятичной системе счисления
        System.out.println(String.format("A monkey ate %,d bananas", eaten));
        */

        //Если нужно, чтобы программа одновременно выполняла несколько действий,
        //создаются потоки, по одному на каждое действие.
        //Нам нужно, чтобы две обезьянки ели бананы одновременно, поэтому создадим
        //два потока.

        Object monitor = new Object();

        //Runnable - это произвольный код, у него нет аргументов, не возвращает результат
        Runnable monkeyAction = () -> {
            int eaten = 0;
            while (bananas > 0) {
                //в скобках указывается любой объект. Он называется монитор.
                //если один поток взял монитор (т.е. вошел в блок), то другие потоки
                //ждут, когда монитор будет возвращен. В данном случае можно написать
                // this, это объект Monkeys, или можно создать специальный объект, который
                //нужен только как монитор
                synchronized (monitor) {
                    if (bananas > 0) {//повторная проверка, не съели ли уже банан
                        bananas--; //1) узнать значение bananas, 2) уменьшить 3) записать обратно
                        eaten++;
                    }
                }
            }
            //eaten - эта переменная у каждой обезьянки своя
            //bananas - глобальная переменная
            System.out.println(String.format("A monkey ate %d bananas", eaten));
        };
        Thread monkey1 = new Thread(monkeyAction); // new Thread(() -> {...});
        Thread monkey2 = new Thread(monkeyAction);

        monkey1.start(); //start() запускает действия как новый поток
        monkey2.start();

        //Задание: обезьянок 10. И еще одна глобальная переменная total. Каждая
        //обезьянка, после того как съела бананы, добавляет в total, сколько всего
        //она съела бананов, и печатает total на экран. Это нужно, чтобы проверить,
        //что все обезьянки в сумме съели ровно 1 000 000 бананов

        //Задание: (можете изменять этот класс, а не тот, где 10 обезьянок)
        //Используйте AtomicInteger вместо int для bananas, он позволяет за одно
        //действие сделать проверку на 0 и вычесть единицу.
    }

    //если не синхронизировать работу двух объезьянок, то в начале каждая решит, что
    //бананов 1_000_000, каждая уменьшит количество до 999_999 и запишет это число
    //в переменную (в поле) bananas. Т.е. Бананов 999_999, но каждая обезьяна считает,
    //что она уже съела один банан.

    //участки кода, которые нельзя выполнять одновременно нескольким потокам, надо
    //синхронизировать, т.е. явно указывать, что только один поток может выполнять
    //этот участок кода. Для этого есть ключевое слово synchronized.
    //Программирование с помощью synchronize очень сложно, особенно, если программа
    //большая и потоков много. Это самый низкоуровневый метод программирования.
}
