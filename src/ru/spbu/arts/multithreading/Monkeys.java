package ru.spbu.arts.multithreading;

import java.util.ArrayList;
import java.util.List;

public class Monkeys {

    //принцип: стараться обходиться без статических методов
    public static void main(String[] args) {
        new Monkeys(); //создаём одну программу про обезьянок
    }

    private int bananas = 1_000_000;
    private int total = 0;

    private Monkeys() {
        //Здесь основная логика программы

        //обезьянка ест бананы
        /*
        int eaten = 0;
        while (bananas > 0) {
            bananas--;
            eaten++;
        }

        //%d - подставить число в десятичной системе счисления
        System.out.println(String.format("A monkey ate %,d bananas", eaten));
        */

        //Если нужно, чтобы программа одновременно выполняла несколько действий, создаются потоки, по одному на каждое
        //действие.
        //Нам нужно, чтобы две обезъянки ели бананы одновременно, поэтому создадим два потока.

        Object monitor = new Object();

        //Runnable - это произвольный код, у него нет аргументов, не возвращает результат
        Runnable monkeyAction = () -> {
            int eaten = 0;
            while (bananas > 0) {
                //в скобках указывается любой объект. Он называется монитор.
                //если один поток взял монитор (т.е. вошёл в блок), то другие потоки ждут, когда монитор будет
                //возвращён. В данном случае this - это объект Monkeys, или можно создать специальный объект, который
                //нужен только как монитор
                synchronized (monitor) {
                    if (bananas > 0) {//повторная проверка, не съели ли уже банан
                        bananas--; //1) узнать значение bananas, 2) уменьшить, 3) записать обратно
                        eaten++;
                    }
                }
            }
            //eaten - эта переменная у каждой обезьянки своя
            //bananas - глобальная переменная
            //используем глобальную переменную, необходима синхронизация
            synchronized (monitor) {
                total += eaten;
            }
            System.out.println(String.format("A monkey ate %,d bananas, total: %,d", eaten, total));

        };

        for (int i = 0; i < 10; i++) {
            Thread monkey = new Thread(monkeyAction);
            monkey.start();
        }

        /*Thread monkey1 = new Thread(monkeyAction); // new Thread(() -> {...});
        Thread monkey2 = new Thread(monkeyAction);

        monkey1.start(); //start() запускает действия как новый поток
        monkey2.start();*/

        //Задание: 1) обезьянок 10. И ещё одна глобальная переменная total. Каждая обезьянка, после того как съела бананы,
        //добавляет в total, сколько всего она съела бананов, и печатает total на экран. Это нужно, чтобы проверить,
        //что все обезьянки в сумме съели ровно 1 000 000 бананов
    }

    //если не синхронизировать работу двух обезьянок, то в начале каждая решит, сто бананов 1_000_000, каждая уменьшит
    //количество до 999_999 и запишет это число в переменную (в поле) bananas. Т.е. бананов 999_999, но каждая считает,
    //что она уже съела один банан.

    //участки кода, которые нельзя выполнять одновременно нескольким потокам, надо синхронизировать, т.е. явно
    //указывать, что только один поток может выполнять этот участок кода. Для этого есть ключевое слово synchronized.
    //Программирование с помощью synchronize очень сложно, особенно, если программа большая и потоков много. Это самый
    //низкоуровневый метод программирования.


}
